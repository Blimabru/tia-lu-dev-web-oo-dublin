Carta de boas-vindas,

**Contextualização:**

A FoodDelivery é uma empresa de tecnologia sediada em Salvador \- BA desde 2025\. Nós passamos por algumas transformações e, como você pode ver, estamos em um novo momento. Nós até mudamos de sede\! Mas o nosso desafio continua o mesmo: conectar restaurantes, bares, projetos gastronômicos, e agora mercados e farmácias, aos consumidores em qualquer lugar com apenas um clique na palma de sua mão. Estamos desenvolvendo novas funcionalidades e trazendo aos nossos clientes: empreendedores e consumidores finais, o melhor conforto e agilidade possível. E nada como automações nos serviços para dar aquela experiência premium, não é?

	Neste ano, a foodDelivery volta com o seu programa de trainee mais forte e robusto que nunca. Parabéns por terem sido aprovados\! Quais de vocês serão as próximas sandies ou juniors das nossas equipes? Nós estamos ansiosos para desenvolver os seus talentos. Vocês vão ser integrados aos nossos times da área de Dados, Desenvolvimento Mobile Nativo e Desenvolvimento Web e farão parte do nosso projeto mais ambicioso: o Lu delivery. Vamos nessa?

	Como trainees na área de Desenvolvimento Web Orientado a Objetos, vocês enfrentarão quatro desafios crescentes ao longo do semestre. Acreditamos que o desenvolvimento de software é uma atividade social, por isso, vocês trabalharão em pequenos grupos, com metas e entregas claras, e serão avaliados pela qualidade do que entregam, pelo esforço nas tarefas, pela organização e clareza. 

Vocês desenvolverão um protótipo de aplicação web, focando na implementação do backend. As etapas incluem: 1\) Desenvolvimento do backend e manipulação de dados locais e remotos; 2\) Integração com APIs; e 3\) Otimização de desempenho e gerenciamento de estados. Os desafios não são simples, mas serão desenvolvidos em grupo, e vocês verão que a colaboração e as competências sociais são fundamentais para o sucesso. Esperamos que se sintam inspirados e motivados neste processo formativo.

**Manual de Conduta:** 	

Nos últimos anos, o uso de IA generativas por parte dos nossos candidatos nos trouxe uma reflexão importante: estamos preocupados apenas em fazer entregas de código ou estamos preocupados em fazer entrega de valor? Nós da foodDelivery não temos problema algum com o uso de IAs Generativas, inclusive achamos essas ferramentas interessantes no apoio do processo formativo de vocês, assim como um contato positivo com novas culturas empresariais. Entretanto, isso exige mais de vocês, que não podem ser apenas escritores de código, pois isso, como vocês já repararam, as IAs generativas sabem fazer tendo um prompt bem escrito. O nosso objetivo nesse processo é saber se os nossos novos talentos sabem resolver problemas. Se eles compreendem o que estão fazendo e o porquê estão fazendo. Afinal, **se você não sabe o problema que quer resolver, nenhum prompt de IA vai resolvê-lo para você.** Desta forma, qual o seu valor como profissional? É isso que vamos explorar neste semestre. 

Nesta primeira etapa, temos alguns objetivos claros para serem desenvolvidos: uma revisão de estatística e uma introdução à exploração de dados. Além disso, queremos acostumar a vocês a usarem repositórios compartilhados, utilizando, inicialmente, o modelo de desenvolvimento centralizado (ou [Centralized Git Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows)). Falando em Git, vocês já estão em um momento da sua formação em que ferramentas de versionamento de código devem ser consideradas competências básicas. Contudo, se você ainda não se sente confortável com o uso da ferramenta Git, você pode estudar esse curso: [Curso em Video: Git](https://www.youtube.com/watch?v=xEKo29OWILE&list=PLHz_AreHm4dm7ZULPAmadvNhH6vk9oNZA&index=1) ou esse outro curso [Minicurso de Git: Código Fonte](https://www.youtube.com/watch?v=ts-H3W1uLMM). Nós recomendamos fortemente que vocês comecem a aprender a ferramenta o quanto antes e estude ambos, se possível for. **Nós vamos considerar que a aprendizagem dessa ferramenta está sendo consolidada nessa primeira entrega, mas nas demais, vamos considerar que essas pequenas coisas já foram superadas.** 

Além da ferramenta de versionamento, vamos avaliar em vocês a sua proficiência na linguagem de programação **Java**. Queremos avaliar o seu conhecimento em estrutura de dados e a aplicação delas na resolução de problemas. Se você ainda não se sente confortável com a linguagem Java, recomendamos esse curso: [Curso em video: Programação Orientada a Objetos em Java](https://www.youtube.com/watch?v=KlIL63MeyMY&list=PLHz_AreHm4dkqe2aR0tQK74m8SFe-aGsY). Você também terá suporte do seu padrinho ao longo do semestre, mas estudar e, principalmente, **PRATICAR** é fundamental. Não adianta apenas conhecer, é preciso **PRATICAR**. 

**Atenção:  Não pegue atalhos nesse caminho\! Por favor, não faça as IAs generativas executar uma tarefa que é sua. Por um segundo, pense: Se ela faz o que você deveria fazer, por que alguém te contrataria e não pagaria uma assinatura dela? Se ela não fica doente, não atrasa, não tem problemas pessoais e é infinitamente mais barata do que você, por que alguém te contrataria para você escrever um prompt para ela? Você, talvez, ainda não tenha a experiência de carreira suficiente para ter o seu valor provado. Não se iluda\! Não conte mentiras para você\! Seja honesto nesse processo\! Aprenda, pois para quem está entrando no mercado, o seu valor vai ser fazer o que uma IA generativa não faz.**

Então, nesse momento, você já percebeu que temos como base três coisas: (1) saber como fazer é tão importante quanto fazer; (2) saber usar ferramenta de versionamento de código é peça fundamental no desenvolvimento das atividades desse semestre e (3) aprender Java não é uma opção, é obrigatório\! Mas como você será avaliado sobre esse pontos? Vamos ver nas próximas seções. 

**Produto**

Quando pensamos em trainees na área de desenvolvimento mobile nativo na FoodDelivery, nós pensamos em duas características claras: uma pessoa boa em lógica de programação e em Java. Como a nossa parceria com a Unex não é recente, nós sabemos que vocês já passaram pelas aventuras de Algoritmos, Estrutura de Dados e talvez até mesmo um pouco de Desenvolvimento de API. Mas você sabe por que esses conteúdos são tão importantes? Porque com eles, vocês serão capazes de explorar uma série de soluções computacionais para construir o backend das suas aplicações. 

	Nas próximas etapas do seu trabalho como trainee, você vai focar na implementação do backend em Java, utilizando Spring Boot e MySQL para manipulação de dados locais e remotos, e na integração com APIs. Discutiremos também o conceito de Backend For Frontend (BFF) e como ele otimiza a comunicação com diferentes clientes. Além disso, a aplicação de padrões de projeto será essencial para a construção de um código robusto e manutenível. O domínio desses conhecimentos em engenharia de software é fundamental para o sucesso do projeto.

	Como falamos anteriormente, os projetos deste programa serão implementados em grupos. As equipes devem ter **obrigatoriamente** 5 membros. Não são 4 membros, nem tão pouco 6 membros, mas 5\. Exceções devem ser comunicadas ao tutor e registradas e autorizadas por ele. Cada time vai ter um nome conforme planilha: [Nome dos Times e Seus Membros](https://docs.google.com/spreadsheets/d/1ytH9rP27Qnn_hsqGmyKUdyNrTaJfPUTwZPpWsIWzBjM/edit?usp=sharing). Os nomes dos times foram sorteados no nosso primeiro encontro presencial. 

Neste primeiro desafio, vamos implementar um sistema de pedidos de comida para um restaurante que tem como finalidade gerenciar pedidos e itens de um restaurante, operando exclusivamente via um sistema de linha de comando (CLI \- Command-Line Interface) para gerenciar os pedidos e utilizando a linguagem Java. É crucial que a implementação faça uso de **Classes, Objetos, Atributos, Métodos e Relacionamentos (Associação, Agregação e Composição)**. Para este desafio, focaremos exclusivamente nesses pilares. Conceitos como herança e polimorfismo serão explorados em uma próxima etapa. Deste modo, não devemos utilizar nas nossas implementações herança e polimorfismo. Os dados deverão ser mantidos apenas em memória, ou seja, não haverá persistência em banco de dados.

O sistema deve permitir que os atendentes cadastrem os itens do cardápio, registrem os clientes, criem novos pedidos e acompanhem o progresso de cada pedido, desde a sua aceitação na cozinha até a entrega final ao cliente. Além disso, vamos precisar de relatórios diários para entender o desempenho das vendas.

1. **Gerenciamento de Cardápio:**  
   * **1.1. Cadastrar Novo Item:** O sistema deve permitir o cadastro de novos itens que o restaurante vende (pratos, bebidas, sobremesas). Cada item terá um nome e um preço.  
   * **1.2. Listar Itens:** Exibir todos os itens do cardápio com seus respectivos códigos e preços.  
2. **Gerenciamento de Clientes:**  
   * **2.1. Cadastrar Novo Cliente:** Permitir o registro de novos clientes com nome e telefone.  
   * **2.2. Listar Clientes:** Exibir todos os clientes cadastrados com seus respectivos códigos.  
3. **Gerenciamento de Pedidos:**  
   * **3.1. Registrar Novo Pedido:** Criar um novo pedido para um cliente. O atendente deve primeiro selecionar o cliente e, em seguida, adicionar um ou mais itens do cardápio, especificando a quantidade de cada um.  
   * **3.2. Atualizar Status do Pedido:** Permitir que o status de um pedido seja alterado.  
   * **3.3. Consultar Pedidos por Status:** Listar todos os pedidos que se encontram em um determinado status (ex: listar todos os pedidos "PREPARANDO").  
4. **Relatórios:**  
   * **4.1. Gerar Relatório de Vendas (Simplificado):** Exibir um resumo do dia, contendo a quantidade total de pedidos e o valor total arrecadado.  
   * **4.2. Gerar Relatório de Vendas (Detalhado):** Exibir uma lista detalhada de todos os pedidos do dia, incluindo as informações do cliente, os itens de cada pedido e o valor total de cada um.

### **3\. Regras de Negócio e Detalhes Importantes**

Aqui estão as regras que darão vida ao sistema. Preste muita atenção em como os objetos devem se comportar e interagir.

* **Geração de Códigos e Números:** O sistema deve gerar automaticamente e garantir que sejam únicos:  
  * Um **código numérico** para cada `Cliente` cadastrado.  
  * Um **código numérico** para cada `ItemCardapio` cadastrado.  
  * Um **número de pedido** sequencial para cada `Pedido` registrado. O usuário não deve informar esses números; a aplicação é responsável por criá-los e gerenciá-los.

* **Criação de Pedidos:** A criação de um `Pedido` é um processo com múltiplas etapas: primeiro, associa-se um cliente ao pedido; depois, adicionam-se os itens do cardápio um a um, cada um com sua respectiva quantidade; finalmente, o pedido é confirmado. A construção desse objeto `Pedido` pode se tornar complexa e propensa a erros se um passo for esquecido ou feito fora de ordem. Ele só se torna um pedido válido após a confirmação, quando recebe o status inicial "ACEITO", a data/hora atual e um número único.  
    
* **Ciclo de Vida de um Pedido (Status):** Um pedido tem um ciclo de vida bem definido e as transições de status são rígidas.  
  * Os status possíveis são: `ACEITO`, `PREPARANDO`, `FEITO`, `AGUARDANDO ENTREGADOR`, `SAIU PARA ENTREGA` e `ENTREGUE`.  
  * Um pedido `ACEITO` só pode ir para `PREPARANDO`.  
  * `PREPARANDO` só pode ir para `FEITO`.  
  * `FEITO` só pode ir para `AGUARDANDO ENTREGADOR`.  
  * E assim por diante. O comportamento do objeto `Pedido` e as ações que podem ser executadas sobre ele mudam dependendo de seu status atual. A lógica para controlar essas transições deve ser cuidadosamente implementada para evitar que um pedido vá de "ACEITO" para "ENTREGUE" diretamente, por exemplo.  
      
* **Central de Dados:** O sistema precisa de um único ponto de acesso para gerenciar todos os dados — a lista de todos os clientes, todos os itens do cardápio e todos os pedidos já feitos. A geração dos relatórios precisa consultar essas mesmas listas centralizadas. Devemos garantir que exista apenas **UMA** instância dessa central de dados em todo o sistema para evitar inconsistências e duplicação de informações.  
    
* **Relatórios Flexíveis:** O restaurante precisa de dois tipos de relatórios de vendas: um simplificado e um detalhado. A forma como o relatório é gerado (o algoritmo) muda, mas o ato de "gerar relatório" é conceitualmente o mesmo. O sistema deve ser capaz de escolher qual algoritmo de geração de relatório usar no momento da execução, sem que a classe que solicita o relatório precise conhecer os detalhes de sua implementação.  
    
* **Interface e Operações:** A interface de linha de comando (o menu principal) será o ponto de entrada para todas as operações. Ela precisa de uma maneira simplificada para interagir com os subsistemas de cadastro de clientes, gerenciamento de cardápio e controle de pedidos. Seria ideal ter uma "frente" unificada que ofereça métodos simples como `registrarNovoCliente(...)`, `criarPedido(...)` ou `avancarStatusPedido(...)`, sem que a classe do menu precise conhecer todos os detalhes internos de cada subsistema.  
    
* **Notificações Futuras:** Imagine que, no futuro, sempre que um pedido mudar de status para "SAIU PARA ENTREGA", o sistema precise notificar o gerente ou registrar essa ocorrência em um log específico. A classe `Pedido` não deveria conhecer os detalhes de quem precisa ser notificado. Ela deveria apenas "avisar" que seu estado mudou, e as partes interessadas (que hoje não existem, mas podem existir no futuro) reagiriam a essa mudança. Pense em como estruturar seu código para permitir essa flexibilidade.

### **Ponto de Partida: Diagrama de Classes Parcial**

Para ajudá-lo a começar, fornecemos um diagrama de classes com três das principais classes de domínio do sistema. Você **deve implementar essas classes** conforme o diagrama e, a partir delas, projetar e criar as outras classes necessárias para atender a todos os requisitos.

**Figura 1\. Diagrama de Classe: Modelo Conceitual Inicial**

Cliente (1) --- faz --- (N) Pedido
Pedido (1) --- contém --- (N) ItemPedido
ItemCardapio (1) --- é referenciado por --- (N) ItemPedido

**Analisando o Diagrama:**

* Um `Pedido` é "feito por" exatamente um `Cliente`.  
* Um `Cliente` pode ter um ou mais `Pedidos`. (Note que a cardinalidade no diagrama simplificado pode ser ajustada por você para 1..\*).  
* A relação entre `Pedido` e `ItemCardapio` é de muitos-para-muitos (\* \-- \*). Um pedido pode conter vários itens, e um mesmo item do cardápio pode estar em vários pedidos. **Questão para reflexão:** Como você representará a *quantidade* de cada item dentro de um pedido se a associação é direta? Talvez uma nova classe seja necessária para gerenciar essa relação?

Sua tarefa é entregar um projeto funcional que atenda a todos os requisitos listados. Especificamente, você deve:

1. **Implementar as Classes:** Crie o código para as classes `Cliente`, `Pedido` e `ItemCardapio` conforme o diagrama.  
2. **Projetar e Criar as Demais Classes:** Identifique, projete e implemente todas as outras classes necessárias para o sistema funcionar. Isso inclui classes para gerenciar os menus, controlar o fluxo da aplicação, gerenciar os dados centralizados e resolver a relação entre `Pedido` e `ItemCardapio`.  
3. **Desenvolver a Aplicação CLI:** Crie a lógica da aplicação de linha de comando, com o menu principal e a interação com o usuário.  
4. **Criar o Diagrama de Classes Final:** Ao final, você deve produzir um diagrama de classes completo, mostrando **TODAS** as classes que você criou e como elas se relacionam.

Este desafio testará sua habilidade de traduzir requisitos em um modelo de objetos coeso e funcional. Pense na responsabilidade de cada classe e em como elas devem colaborar.

O projeto deve ser versionado e entregue no repositório de cada equipe. O nome do repositório deve seguir o padrão: tia-lu-dev-web-oo-\<nome\_do\_time\>. Exemplo: tia-lu-dev-web-oo-sao-paulo, para um time que chame São Paulo. Atualize a tabela de [Equipes](https://docs.google.com/spreadsheets/d/1ytH9rP27Qnn_hsqGmyKUdyNrTaJfPUTwZPpWsIWzBjM/edit?usp=sharing) com o link do seu repositório. Não esqueça de adicionar o tutor ao repositório.  Você pode enviar o convite para o nickname: lasilva. **Repositórios com nomes fora do padrão não serão avaliados. A ENTREGA QUE VAI SER AVALIADA VAI SER A QUE ESTIVER NA BRANCH MAIN.** 

Além da implementação da classe, vocês deverão escrever um relatório técnico-científico, explicando as métricas implementadas, ilustrando o comportamento de cada métrica e para que elas servem. O relatório deve ter no máximo 6 laudas, considerando as seções: Introdução, Fundamentação Teórica, Metodologia, Resultados e Discussões, Considerações finais e Referências. **Todas essas seções devem constar no relatório.** 

Como este é o nosso primeiro desafio, vamos dar uma colher de chá. Na Introdução, contextualizem a importância da Programação Orientada a Objetos. Na Fundamentação Teórica, expliquem os conceitos de classes, atributos, construtores, métodos, assim como os conceitos de Diagrama de Classes. Na Metodologia, expliquem como foi implementado o projeto. Em Resultados, apresentem o diagrama de classes da sua solução, alguns pontos importantes de implementação. Em considerações finais, tragam quais pontos foram desafiadores, interessantes e o quê de diferente vocês fariam do que foi feito tendo mais tempo. 

 O relatório deve ser escrito no [Modelo SBC](https://drive.google.com/file/d/1dEAIjAuN5QoUWFa5WASJmpaxEhK39HWN/view?usp=sharing). O relatório deve ser versionado no repositório com o seguinte padrão de nome: relatorio\_tecnico\_\<nome\_da\_equipe\>.pdf. Além de versionado, o relatório deve ser entregue no blackboard no formulário: [Formulário de Submissão de Relatório](https://ftc.blackboard.com/ultra/courses/_93350_1/outline/assessment/test/_11094601_1?courseId=_93350_1&gradeitemView=details&gradebookCategoryId=_1805592_1&autoPostGrades=true). 

Vocês também devem elaborar uma apresentação no [Modelo de Apresentação](https://docs.google.com/presentation/d/1HayWJi__y8W4vx_2zcrZtigDn02aBJdoKDkKZiKsjf0/edit?usp=sharing). As apresentações serão realizadas apenas para o tutor. A apresentação também precisa ser versionada no repositório com o seguinte padrão de nome: apresentacao\_\<nome\_da\_equipe\>.pdf. Além do versionamento, a apresentação deve ser entregue no blackboard no formulário: [Formulário de Submissão de Relatório](https://ftc.blackboard.com/ultra/courses/_93348_1/outline/assessment/test/_11108443_1?courseId=_93348_1&gradeitemView=details&gradebookCategoryId=_1805574_1&autoPostGrades=true).

**Avaliação:** 

Neste semestre, vamos introduzir algumas nomenclaturas que serão importantes ao longo do processo avaliativo e formativo de vocês. Vocês serão solicitados, a cada período de tempo, aproximadamente entre 3 e 4 semanas, uma entrega de valor. Nós chamamos essas solicitações de **demandas**. Vocês atuarão em equipe para entregar o resultado dessas **demandas** que vem da área de produto. Quem especifica o produto é conhecido, em ambientes que utilizam metodologias ágeis, de **Product Owner**, ou simplesmente, **PO (lê-se Pi-Ou)**. A entrega de valor realizada ao final de cada demanda vai ser chamada de **Entregável**.  Em geral, os **entregáveis** são arquivos de **código fonte** que realizam uma atividade. Nós vamos usar siglas para nos referimos aos entregáveis, por exemplo: **Entregável 1 \- E1, Entregável 2 \- E2,** e assim por diante. 

A cada entrega, vocês produzirão um relatório técnico científico no modelo **SBC**. O relatório deve ter **no máximo 6 laudas**, incluindo todas as seções (inclusive as referências). O relatório precisa ser entregue no mesmo dia da entrega do código fonte. Após a data da entrega, vocês passarão por uma **avaliação oral**. Nessa avaliação, vocês terão que apresentar o contexto do que foi desenvolvido e serão questionados pelo tutor. Tanto o relatório técnico quanto a avaliação oral formam juntos um **peso** que vai ser utilizado para ponderar o valor obtido no entregável. Deste modo, o valor final do entregável será: 

VF\_E \= ((RT \+ AO) \* E ) / 5 

onde: 

**VF\_E** é o Valor Final do Entregável 

**RT** \- Relatório Técnico-Científico 

**AO** \- Apresentação Oral 

**E** \- Valor do Entregável 

**Observações importantes:** 

1. Relatórios fora do padrão estabelecido serão pontuados com zero.  
2. Relatórios que não estejam no formato pdf serão pontuados com zero.   
3. Apresentações fora do padrão estabelecido serão pontuadas com zero.   
4. As apresentações devem ser realizadas no máximo de 7 minutos.   
5. Apenas um membro da equipe vai realizar a apresentação. O membro da equipe será escolhido pelo tutor no dia da apresentação.   
6. Se a equipe não apresentar, o valor da apresentação será zero.   
7. Se um membro da equipe faltar a apresentação no dia ficará com 30% da nota de apresentação da equipe.   
8. Apresentações e relatórios não versionados serão pontuados com zero. 

**Pontuação:** 

| Atividade | Peso |
| :---- | :---- |
| **Relatório Técnico** | 2 |
| **Apresentação** | 3 |

| Atividade | Nota |
| :---- | :---- |
| **Entregável 1** | 5 pontos |

**Prazos:**

| Atividade | Data |
| :---- | :---- |
| **OAT1.1 \- Entregável** | 30/08/2025 |
| **Apresentação** | até 26/09/2025 |

